---
title: Fun with C++26 reflection - Keyword Arguments
date: 2025-01-24T04:20:29+00:00
categories: [C++,]
tags: [C++, C++26, reflection, experiments]
author: Che
---

In this blog post we'll explore implementing order-independent keyword arguments for C++ through use of C++26's [proposed reflection](https://wg21.link/p2996) features. I stumbled across this a few days ago while experimenting with reflection and thought it might be worthwhile to share, since it nicely showcases just how powerful the proposed reflection features are.

An example implementation of the technique presented in this blog post can be found on [GitHub](https://github.com/tsche/kwargs). It can be used with Bloomberg's experimental [P2996 clang fork](https://github.com/bloomberg/clang-p2996). Feel free to leave a star if you enjoy these shenanigans. :)


## Prior art
Named, labeled or keyword arguments have been proposed many times throughout the years, but as [EWG issue 150](https://cplusplus.github.io/EWG/ewg-closed.html#150) notes: all of these attempts have failed. To give you a short overview, here is several proposals on that topic:
- [n4172](https://wg21.link/n4172) Named arguments
- [p1229](https://wg21.link/p1229) Labelled Parameters
- [p0671](https://wg21.link/p0671) Self-explanatory Function Arguments

Since none of these made it, we have to be somewhat creative to get similar functionality in C++. This also has been done numerous times, although every attempt has numerous drawbacks.

To give you a short overview, here's what you can do in standard C++ thus far:

### Designated initializers
Let's start with the simplest way to achieve keyword argument-like syntax. C++20 added designated initializers for aggregate types, which gives us the initialization syntax `Point{.x=42, .y=7}`. 

In a function call's argument list the type can potentially be deduced, so we could write `foo({.x=2, .y=2})`. While this requires extra curly braces and `.`-prefixes for every member name, syntactically this is almost what we want.

Usage example ([run on compiler explorer](https://godbolt.org/z/54znGc1aM)):
```c++
struct FooArgs {
    int x;
    int y;
};

void foo(FooArgs args){
    std::println("x: {} y: {}", args.x, args.y);
}

struct BarArgs {
    int x;
};

void bar(int x, FooArgs args){
    std::println("x: {} y: {}", x, args.x);
}

int main() {
    // optional keyword arguments
    foo({.x = 2, .y = 42});
    foo({.x = 2});

    // positional arguments and keyword arguments
    bar(12, {.x = 10});
}
``` 

Unfortunately this has various drawbacks. 

First of all, we need to define a lot of types for the keyword arguments out-of-line. Optional keyword arguments can be modelled by wrapping the member in a `std::optional`, but additional keyword arguments cannot be passed. 

The order in which keyword arguments appear also matters, it must match the definition order of the members - fortunately though you can skip members.


### Helper objects
As it turns out, making the desired syntax `bar(12, x = 10)` valid C++ is not actually that hard. To do this, let `x` be an object of some type with an `operator=` overload that wraps the value in some way that later lets us retrieve it by name. 

You might be able to see the problem here already - this needs to be done for _every_ named argument.

Essentially, all you need to do at the library side of things is define a wrapper, like so:
```c++
template <typename T, util::fixed_string Name>
struct TypedArg {
    T value;
    decltype(auto) operator*(this auto&& self){
        return std::forward<decltype(self)>(self).value;
    }
};

template <util::fixed_string Name>
struct Arg {
    template <typename T>
    TypedArg<T, Name> operator=(T&& value) const{
        return {std::forward<T>(value)};
    }
};
```
Now we can introduce helpers by saying 
```c++
constexpr inline Arg<"name"> name;
```

This could potentially be hidden behind a macro to reduce the possibility of messing up the repetition of the argument's name, but you still need to carefully do this wherever keyword arguments shall be used.

To accept keyword arguments, functions must wrap their parameters as well - `void foo(int x, int y)` turns into `void foo(TypedArg<int, "x"> x, TypedArg<int, "y"> y)`. Once again, a macro could help here. Either way, the wrapped value can then be accessed by using the unary `*` operator on these arguments:

```c++
constexpr inline Arg<"x"> x;

void bar(int a, TypedArg<int, "x"> x){
    std::println("a: {} x: {}", a, *x);
}

int main() {
  bar(10, x = 4);
}
```

#### Order-independent arguments

To allow for order-independent arguments, functions can receive the arguments as a pack. We can then pick out the desired keyword arguments by re-using `std::get`'s ability to retrieve a tuple's element by type.
```c++
template <typename Needle, typename... Ts>
decltype(auto) pick(Ts&&... args){
    return *std::get<Needle>(std::make_tuple(std::forward<Ts>(args)...));
}

void oof(auto... kwargs) {
    auto x = pick<Arg<int, "x">>(kwargs...);
    auto y = pick<Arg<int, "y">>(kwargs...);
    std::println("x: {}, y: {}", x, y);
}
```
The same technique can be used to implement optional arguments. To do this, simply let `pick` return a default if none of the argument pack's elements was of the desired type.

<br/>

Here's the full example thus far ([run on compiler explorer](https://godbolt.org/z/fzKnY45od)):
```c++
// order preserving
void foo(Arg<int, "x"> x, Arg<int, "y"> y){
    std::println("x: {} y: {}", *x, *y);
}

// order independent
void oof(auto... kwargs) {
    auto x = pick<Arg<int, "x">>(kwargs...);
    auto y = pick<Arg<int, "y">>(kwargs...);
    std::println("x: {}, y: {}", x, y);
}

// mixed
void bar(int a, Arg<int, "x"> x){
    std::println("a: {} x: {}", a, *x);
}

// need to define helpers for every named argument
constexpr inline Arg<int, "x">::Helper x;
constexpr inline Arg<int, "y">::Helper y;

int main() {
    // mixed
    bar(12, x = 10);

    // order preserving
    foo(x = 2, y = 42);
    // foo(y = 42, x = 2); // error: wrong order

    // order independent
    oof(y=42, x=2);
    oof(x=2,  y=42);
}
``` 

#### `args` variable template
To further improve upon this, we want to eliminate the error-prone and somewhat unpleasant need to define helpers out-of-line first. Since they are all of the same type, we can instead use a single variable template `arg`:
```c++
template <util::fixed_string Name>
constexpr inline Arg<Name> arg{};
```

This allows us to write code like this ([run on compiler explorer](https://godbolt.org/z/GP8GE3n8z)):
```c++
foo(arg<"x"> = 2, arg<"y"> = 42);
bar(12, arg<"x"> = 10);
``` 

Unfortunately that's still rather verbose. Also note that the space between `>` and `=` is required.

#### User-defined literal operator template
Alternatively, we can produce a helper object by using a user-defined literal operator:
```c++
template<util::fixed_string Name>
constexpr Arg<Name> operator ""_arg(){
    return {};
}
```

Usage example ([run on compiler explorer](https://godbolt.org/z/5oPTdsKbz)):
```c++
// optional keyword arguments
foo("x"_arg = 2, "y"_arg = 42);
foo("x"_arg = 2);

// positional arguments and keyword arguments
bar(12, "x"_arg = 10);
``` 

This might be a little prettier than the previous example, but it's still rather verbose. However, if we want the desired syntax back we could still write:
```c++
constexpr inline auto x = "x"_arg;
constexpr inline auto y = "y"_arg;

foo(x=2, y=3);
```

### Reflection
So.. can we do any better? The technique presented in this blog post allows us to write the following code:
```c++
// optional keyword arguments
foo(make_args(x = 2, y = 42));
foo(make_args(x = 2));

// positional arguments and keyword arguments
bar(12, make_args(x = 10));

// references
int const baz = 24;
bar(12, make_args(&x = baz));

// shorthand
int x = 2;
foo(make_args(x, y=23));
```

As you can see, keyword arguments must be wrapped with a macro `make_args(...)`. However, the order they appear in does not matter _and_ we can use shorthands. If this reminds you of lambdas, you're spot on.

## Reflecting lambda closure types
Lambda captures are almost a perfect fit - their order does not matter, their type is deduced and lambdas introduce a class type with every capture corresponding to a non-static data member for us. Unfortunately though lambda closures are neither decomposable through a structured binding nor are lambda captures directly accessible outside of the lambda's body.

Nevertheless, C++26 reflection allows us to reflect private members.

>**Expansion**
>
> Since this blog post is about [P2996](https://wg21.link/p2996), expansion statements (as proposed in [P1306](https://wg21.link/p1306)) are not used. 
> In lieu of expansion statements, we will instead use the `expand` helper. The syntax might look a little weird at first, but you'll get used to it.
>```c++
>//p1306 expansion statement
>template for (constexpr auto member : nonstatic_data_members_of(^^Type)){
>    // ...
>}
>
>// roughly equivalent to
>[:expand(nonstatic_data_members_of(^^Type)):]
>  >> []<std::meta::info... Member>{
>      // ...
>  }
>```
>
> The implementation of `expand` looks roughly like this:
>
>```c++
>namespace impl {
>template <auto... Vs>
>struct Replicator {
>    template <typename F>
>    constexpr decltype(auto) operator>>(F fnc) const {
>        return fnc.template operator()<Vs...>();
>    }
>};
>
>template <auto... Vs>
>constexpr static Replicator<Vs...> replicator{};
>}  // namespace impl
>
>template <std::ranges::range R>
>consteval auto expand(R const& range) {
>    std::vector<std::meta::info> args;
>    for (auto item : range) {
>        args.push_back(reflect_value(item));
>    }
>    return substitute(^^impl::replicator, args);
>}
>```
>
> This has the added benefit of giving us the items as a pack.
>
{: .prompt-tip }


With `expand` we can now print some information about a lambda closure type, so let's do that.
```c++
int main() {
    int baz = 42;
    auto closure = [x=420, &bar = baz]{};
    using closure_type = decltype(closure);

    [:expand(nonstatic_data_members_of(^^closure_type)):] >> [&]<auto... members>{
        (std::println("has identifier: {} - type: {:<5} - value: {}", 
                      has_identifier(members),
                      display_string_of(type_of(members)),
                      closure.[:members:]), ...);
    };
}

// Output:
// has identifier: false - type: int   - value: 420
// has identifier: false - type: int & - value: 42
```
[Run on Compiler Explorer](https://cpp26.godbolt.org/z/W67WhrETq)

Good news, we can get types of lambda captures and references are properly handled. Even better, we can splice in the respective member to access captures outside of the lambda (for now.. see [P3587](https://wg21.link/p3473)). Bad news though, the members are all unnamed.

> **Order of captures**
>
> Note that the declaration order of the lambda closure's members is unspecified (see [[expr.prim.lambda.capture]/10](https://standards.pydong.org/c++/expr.prim.lambda.capture#10)). While the following hackery with lambdas might work, it is not guaranteed. 
{: .prompt-warning }

## Parsing the capture list
To work around that we can use a macro to define the lambda _and_ stringify its capture list. The stringified version can then be parsed to retrieve the names.
```c++
namespace kwargs {
template <fixed_string str, typename T>
auto from_lambda(T&& captures) {
    // ...
}
}

#define make_args(...) ::kwargs::from_lambda<#__VA_ARGS__>([__VA_ARGS__] {})
```

### Parser utilities
To make life easier, let's first define a `Parser` base class.

```c++
struct Parser {
    std::string_view data;
    std::size_t cursor{0};

    [[nodiscard]] constexpr char current() const { return data[cursor]; }
    [[nodiscard]] constexpr bool is_valid() const { return cursor < data.length(); }
};
```
Since whitespace is often not significant, we'll need some utility to skip whitespace.
```c++
constexpr bool is_whitespace(char c) {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r';
}
constexpr void skip_whitespace() {
    while (is_valid()) {
        if (char c = current(); is_whitespace(c) || c == '\\') {
            ++cursor;
        } else {
            break;
        }
    }
}
```

Another handy utility is skipping to the next occurrence of some character that is not within curly braces, parentheses or square brackets. Since it does not matter if the code we parse is syntactically valid, counting `(]` the same way as `()` is fine.

```c++
constexpr void skip_to(std::same_as<char> auto... needles) {
    int brace_count = 0;
    while (is_valid()) {
        if (char c = current(); brace_count == 0 && ((c == needles) || ...)) {
            break;
        } else if (c == '[' || c == '{' || c == '(') {
            ++brace_count;
        } else if (c == ']' || c == '}' || c == ')') {
            --brace_count;
        }
        ++cursor;
    }
}
```

### Parsing

Let's address the elephant in the room - parsing even a subset of C++ correctly is difficult. Capture lists of lambda expressions can be extremely complex, but the vast majority of "odd" ones aren't really meaningful in the context of named arguments. This allows us to limit the scope of this parser.


Obviously we want captures of the form `arg1 = 123, arg2 = ident`, but it would also be nice to allow for shorthands such as `x,y` - which would be equivalent to `x=x,y=y`. Also, capturing arguments by reference can sometimes be desired - hence, our capture list parser must not fail for captures of the form `&foo = bar` or `&foo`.

```c++
while (is_valid()) {
    skip_whitespace();

    if (current() == '&') {
        // might be captured by reference
        ++cursor;
        skip_whitespace();
    }

    std::size_t start = cursor;
    // find `=`, `,` or whitespace
    skip_to('=', ',', ' ', '\n', '\t');
    names.emplace_back(start, cursor - start);
    // skip ahead to next capture
    // this won't move the cursor if the current character is already `,`
    skip_to(',');
    ++cursor;
}
```

I've omitted it here for brevity, but it at this point it's advisable to reject various captures that would not make sense for our use. This includes:

| Capture Kind                  | Reasoning                                                            |
|-------------------------------|----------------------------------------------------------------------|
| Capturing `this`              | We cannot name a member `this`, hence injecting the class will fail. |
| Default captures `=` and `&`  | The lambda's body is empty, hence this will not capture anything.    |
| Packs `...foo`                | We need to name every argument.                                      |


## Wrapping things up
Since we now know the names of the lambda's unnamed members, we can inject an aggregate class type with **named** members of appropriate type for every capture of the lambda type.

First, we need to parse the stringified capture list and create data member specifications that associate every non-static data member of the lambda closure with its respective name. This can then be used to inject the named argument container type.
```c++
template <typename Impl>
struct [[nodiscard]] kwargs_t : Impl {
  using type = Impl;
};

template <util::fixed_string Names, typename... Ts>
constexpr auto make(Ts&&... values) {
  struct kwargs_impl;
  consteval {
    std::vector<std::meta::info> types{^^Ts...};
    std::vector<std::meta::info> args;

    auto parser = CaptureParser{Names.to_sv()};
    if(!parser.parse()){
        // name list rejected or parsing error, abort
        return;
    }

    // associate every argument with the corresponding name
    // retrieved by parsing the capture list

    for (auto [member, name] : std::views::zip(types, parser.names)) {
        args.push_back(data_member_spec(member, {.name = name}));
    }
    define_aggregate(^^kwargs_impl, args);
  };

  // ensure injecting the class worked
  static_assert(is_type(^^kwargs_impl), "Could not inject named argument class");

  return kwargs_t<kwargs_impl>{{std::forward<Ts>(values)...}};
}
```
This can already be used to make named arguments without the use of lambdas - ie. by invoking `make<"x,y">(123, "foo")`.

Finally we need to steal the provided lambda's members to produce our keyword argument container through the `make_args` macro we defined earlier.
```c++
template <util::fixed_string Names, typename T>
auto from_lambda(T&& lambda) {
  using fnc_t = std::remove_cvref_t<T>;

  return [:meta::expand(nonstatic_data_members_of(^^fnc_t)):]
    >> [&]<auto... member>() {
        return make<Names>(lambda.[:member:]...);
    };
}
```

To make usage at the receiving side a little easier, `kwargs_t<T>` shall also implement the [tuple protocol](https://en.cppreference.com/w/cpp/utility/tuple/tuple-like). This means we need to provide specializations for `std::tuple_size` and `std::tuple_element`. Also we'll need to implement `get` for `kwargs_t<T>`.

```c++
template <typename T>
struct std::tuple_size<kwargs_t<T>>
    : public integral_constant<size_t, 
        nonstatic_data_members_of(^^std::remove_cvref_t<T>).size()>{};

template <std::size_t I, typename T>
struct std::tuple_element<I, kwargs_t<T>> {
    using type = [:get_nth_field(^^T, I):];
};

template <std::size_t I, typename T>
constexpr auto get(kwargs_t<T> const& t) noexcept {
    return t.[:get_nth_field(^^T, I):];
}

```

Additionally we want to be able to get kwargs by name. Since this might fail, it can be appropriate to return a default value if no member with the requested name was found.

```c++
template <fixed_string name, typename T>
constexpr auto get(kwargs_t<T> const& t) {
    return t.[:get_nth_field(^^T, get_member_index(name.to_sv())):];
}

template <fixed_string name, typename T, typename R>
constexpr auto get(kwargs_t<T> const& t, R default_) {
    if constexpr (get_member_index<T>(name.to_sv()) == -1UZ) {
        return default_;
    } else {
        return t.[:get_nth_field(^^T, get_member_index<T>(name.to_sv())):];
    }
}
```

## Usage
Consider the following example:
```c++
#include <concepts>
#include <print>

#include <kwargs.h>


template <typename T>
requires requires(T const& kwargs) {
    { kwargs.x } -> std::convertible_to<int>;
}
void foo(int y, kwargs_t<T> const& kwargs) {
    std::println("y: {} x: {} kwarg y: {}", y, kwargs.x, get<"y">(kwargs, 42));
}


int main() {
    foo(3, make_args(x = 3));
    foo(3, make_args(x = 3, y = 17));
}
```
[Run on compiler explorer](https://cpp26.godbolt.org/z/787s3bfYP)

We can now express optionality of keyword arguments (or rather lack thereof) through constraints.

Since required keyword arguments must exist, we can reference them using the member access operator. For optional keyword arguments such as `y` we can instead use `get` and have it return a default in case no such argument was found.


## Bonus: Format strings with named arguments
Aside from positional arguments, the awesome `fmt` library also allows for named arguments. You might be able to recognize the approach used in `fmt`, here's what the code would look like:
```c++
fmt::print("Hello, {name}! The answer is {number}. Goodbye, {name}.",
           fmt::arg("name", "World"), fmt::arg("number", 42));

// alternatively
using namespace fmt::literals;
fmt::print("Hello, {name}! The answer is {number}. Goodbye, {name}.",
           "name"_a="World", "number"_a=42);
```

Let's do the same with `erl::kwargs_t`.

### Transforming the format string
Since `std::format` does not yet have support for `fmt`'s named arguments, we can instead transform named arguments to positional arguments. This will look something like this:

```c++
struct FmtParser : Parser {
    constexpr std::string transform_impl(std::ranges::input_range auto const& names) {
        std::string out;
        int brace_count = 0;
        while (is_valid()) {
            out += current();
            if (current() == '{') {
                ++cursor;
                if (current() == '{') {
                    // double curly braces means escaped curly braces
                    // => treat the content as text
                    auto start = cursor;
                    // skip to first unbalanced }
                    // this will match the outer {
                    skip_to('}');
                    out += data.substr(start, cursor - start);
                    continue;
                }

                // find name
                std::size_t start = cursor;
                skip_to('}', ':');
                // ++index;
                auto name = data.substr(start, cursor - start);

                // replace name
                auto it = std::find(names.begin(), names.end(), name);
                auto idx = std::distance(names.begin(), it);
                out += itoa(idx);

                out += current();
            }
            ++cursor;
        }
        return out;
    }

    template <typename Impl>
    consteval static std::string transform(std::string_view str){
        std::vector<std::string_view> names = nonstatic_data_members_of(^^Impl)
            | std::views::transform(std::meta::identifier_of)
            | std::ranges::to<std::vector>();
        return FmtParser{str}.transform_impl(names);
    }
};
```
### Wrapping `std::format_string`
At some point we will have to produce a `std::format_string`. To avoid having to resort to runtime format checking, we can instead instantiate a template function that handles formatting for us. 

So let's first provide a replacement for the `std::format_string` argument of `format` - note that the constructor must be `consteval`.

```c++
template <std::meta::info Args>
struct NamedFormatString {
    using format_type = std::string (*)([:Args:] const&);
    format_type format;

    template <typename Tp>
        requires std::convertible_to<Tp const&, std::string_view>
    consteval explicit(false) NamedFormatString(Tp const& str) {
        auto fmt = fixed_string{str};
        format = extract<format_type>(
            substitute(^^format_impl, {std::meta::reflect_value(fmt), Args}));
    }
};
```
This will instantiate `format_impl` with the format string as constant template argument for us.

In `format_impl` we need to transform the format string to replace all named arguments with positional arguments. Afterwards we can just delegate to `std::format`.
```c++
template <fixed_string fmt, typename Args>
std::string format_impl(Args const& kwargs) {
    static constexpr auto fmt_fixed = std::meta::define_static_string(
        FmtParser::transform<typename Args::type>(fmt.to_sv()));

    return [&]<std::size_t... Idx>(std::index_sequence<Idx...>) {
        using fmt_type = std::format_string<std::tuple_element<Idx, Args>...>;
        return std::format(fmt_fixed, get<Idx>(kwargs)...);
    }(std::make_index_sequence<std::tuple_size_v<Args>>{});
}
```

We can now define two versions of `format` - one for named arguments and one to wrap the existing functionality of `std::format`. 

```c++
template <typename T>
    requires(is_kwargs<T>)
void print(NamedFormatString<^^T> fmt, T const& kwargs) {
    fmt.print(kwargs);
}

template <typename... Args>
    requires(sizeof...(Args) != 1 || (!is_kwargs<std::remove_cvref_t<Args>> && ...))
void print(std::format_string<Args...> fmt, Args&&... args) {
    std::print(fmt, std::forward<Args>(args)...);
}
```
`std::print` and `std::println` can be wrapped in the same way.

### Usage
Instead of `std::print("foo: {0} - {1} - {0}", 123, 42)`, we can now say `erl::print("foo: {foo} {bar} {foo}", make_args(foo=123, bar=42))`. The order in which arguments appear in `make_args` does not matter.

Here's a full example:

```c++
#include <vector>
#include <iostream>

#define KWARGS_FORMATTING 1
#include <kwargs.h>

int main(){
  int x = 3;
  std::vector<int> list = {1, 2, 3, 4};

  erl::print("{} {}\n", 42, x);
  erl::print("{1} {0}\n", x, 42);
  erl::print("{x} {y}\n", make_args(x=42, y=x));

  erl::print("x: {} list: {} {{str}}: {}", x, list, "foo");
  erl::print("x: {0} list: {2} {{str}}: {1}", x, "foo", list);
  erl::println("x: {x} list: {list} {{str}}: {str}", 
               make_args(x=x, str="foo", list=list));
  erl::println("x: {x} list: {list} {{str}}: {str}", 
               make_args(x, str="foo", list));
  
  std::cout << erl::format("{x} {y}", make_args(x, y=3)) << '\n';
}
```
[Run on compiler explorer] (https://cpp26.godbolt.org/z/jh6M7bf6v)
