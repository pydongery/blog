---
title: Reflective Metaprograms - Autoload
date: 2025-03-17T04:20:29+01:00
categories: [C++,]
tags: [C++, C++26, reflection, metaprogramming, TMP]
author: Che
---
While browsing C++ communities I recently saw a very interesting use for reflection. In this blog post we'll explore how a previously very difficult problem could soon be solved in just a few lines of code thanks to [P2996 Reflection](https://wg21.link/p2996).

An example implementation of the techniques discussed in this blog post can be found on [Github](https://github.com/tsche/autoload). It's packaged as a single-header library with support for C++20 and onwards.

## Loading libraries dynamically
In a lot of applications we need to dynamically load libraries at runtime. To actually use any symbols exported from the library, it is unfortunately necessary to manually resolve them.

While this is easy enough, it'd be a lot nicer if we could use C++ to wrap the (desired subset) of the library's exported symbols in a meaningful way.

### Resolving symbols
So, to finally get to the original problem description:
> I have a struct with a bunch of function pointer members and I want to automatically hook them up using `dlsym`/`GetProcAddress`.


### Library loading utilities

## Reflecting aggregates in C++20

### Decomposing via structured binding
### Reflecting member names

## Reflection

## Wrapping C functions

One interesting property of this approach is that we can simply inherit from `Library<Interface>`. This allows for safe C++ wrappers around dangerous C library functions.
